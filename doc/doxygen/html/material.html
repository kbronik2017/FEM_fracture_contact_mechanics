<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.7"/>
<title>FEBio: Material Plugins</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="febio_logo.png"/></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">FEBio
   &#160;<span id="projectnumber">2.0</span>
   </div>
   <div id="projectbrief">Finite Elements for Biomechanics</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.7 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('material.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Material Plugins </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>In this section we will look at the details of setting up a plugin that implemetns a new constitutive model. The new material will be integrated seamlessly in FEBio's framework so that the user can take immediate advantage of additional functionality such as reading material parameters from the xml-formatted FEBio input file, serialization to the restart archive, parameter optimization and more.</p>
<p>The basic procedure for creating a new material for FEBio requires the following steps.</p>
<ol type="1">
<li>Defining a new material class by deriving it from an available base class.</li>
<li>Registering the material with FEBio's framework.</li>
<li>Defining the material parameters.</li>
<li>Implementing the initialization function (optional)</li>
<li>Defining a MaterialPoint structure (optional)</li>
<li>Implementing the stress and tangent functions.</li>
</ol>
<p>Next, the steps for the basic procedure will be discussed in more detail.</p>
<h1><a class="anchor" id="mat_sec1"></a>
Basic Procedure</h1>
<h2><a class="anchor" id="step1"></a>
Defining the material base class</h2>
<p>FEBio is written in C++ and therefore the new material implementation must be coded in C++ as well. Each material requires a separate class and hence the first step is to define a new class. The class has to be derived from one of the available material base classes. In this section it is assumed that the new material is derived from <a class="el" href="class_f_e_elastic_material.html" title="Base class for (hyper-)elastic materials. ">FEElasticMaterial</a>. Materials that are derived from this base class will be materials that are used to describe isotropic, compressible solid materials. An example of such a material is the neo-Hookean material, which will be used as a case study in this section. The implementation of more advanced models will be discussed later, but they too have to follow most of the same steps.</p>
<p>The definition of the neo-Hookean material class looks as follows. Note that the actual implementation of this class might look a bit different in the code. Only the important aspects are touched upon here.</p>
<div class="fragment"><div class="line"><span class="keyword">class </span><a class="code" href="class_f_e_neo_hookean.html">FENeoHookean</a> : <span class="keyword">public</span> <a class="code" href="class_f_e_elastic_material.html">FEElasticMaterial</a></div>
<div class="line">{</div>
<div class="line">    <span class="keyword">public</span>:</div>
<div class="line">        <span class="comment">// material parameters</span></div>
<div class="line">        <span class="keywordtype">double</span>  <a class="code" href="class_f_e_neo_hookean.html#a152e5b285a5e0e32af668e0907d28c71">m_E</a>;</div>
<div class="line">        <span class="keywordtype">double</span>  <a class="code" href="class_f_e_neo_hookean.html#a47f3436c17fdae4e73b7b77ddf423d9c">m_v</a>;</div>
<div class="line"></div>
<div class="line">    <span class="keyword">public</span>:</div>
<div class="line">        <span class="comment">// Cauchy-stress calculation</span></div>
<div class="line">        <span class="keyword">virtual</span> <a class="code" href="classmat3ds.html">mat3ds</a> <a class="code" href="class_f_e_neo_hookean.html#aad1f0effb7279cb2df0264df25696d2a">Stress</a>(<a class="code" href="class_f_e_material_point.html">FEMaterialPoint</a>&amp; pt);</div>
<div class="line"></div>
<div class="line">        <span class="comment">// Spatial elasticity tensor calculation</span></div>
<div class="line">        <span class="keyword">virtual</span> <a class="code" href="classtens4ds.html">tens4ds</a> <a class="code" href="class_f_e_neo_hookean.html#a267374187b8d7f55f5058814ef8a4197">Tangent</a>(<a class="code" href="class_f_e_material_point.html">FEMaterialPoint</a>&amp; pt);</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// class initialization (optional)</span></div>
<div class="line">        <span class="keyword">virtual</span> <span class="keywordtype">void</span> <a class="code" href="class_f_e_neo_hookean.html#adae9c15f1590c97bb4ba979f650dc558">Init</a>();</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// declare as having a parameter list</span></div>
<div class="line">        DECLARE_PARAMETER_LIST();</div>
<div class="line">};</div>
</div><!-- fragment --><p>The class derives, as expected, publicly from <a class="el" href="class_f_e_elastic_material.html" title="Base class for (hyper-)elastic materials. ">FEElasticMaterial</a>. It then defines a couple of public variables. These variables will store the material parameters as is discussed below. After this, the class also declares a few member functions. Note that all these functions are virtual. Furthermore, the Stress and Tangent are declared as abstract in the base class, so they have to be overridden in the derived class. The Init function is optional, since a default implementation (which does nothing) is provided.</p>
<p>At this point it is useful to discuss a common practice in adding new classes in C++. Usually the definition of the class is split over two separate files. One file, the so-called header file, declares the new class. The implementation of the function members are placed in a separate file, usually a .cpp file. FEBio follows this practice and therefore the neo-Hookean implementation is spread over two files: the <a class="el" href="_f_e_neo_hookean_8h_source.html">FENeoHookean.h</a> contains the class definition and FENeoHookean.cpp contains the member function definitions. It is recommended that the implementation of new materials follows this practice.</p>
<p>The last line of the class definition contain a macro that will help with the registration the class' material parameters.</p>
<h2><a class="anchor" id="step2"></a>
Registering the new material</h2>
<p>In order for FEBio to recognize the new material, the material needs to be registered with the framework. In a plugin, this is done by defining a factory class and creating an instance of this class and then passing a pointer to the factory back to FEBio in the PluginGetFactory function.</p>
<p>A material factory class can be defined like this.</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>MyFactory : <span class="keyword">public</span> <a class="code" href="class_f_e_core_factory.html">FECoreFactory</a></div>
<div class="line">{</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    MyFactory() : <a class="code" href="class_f_e_core_factory.html">FECoreFactory</a>(FEMATERIAL_ID, <span class="stringliteral">&quot;my_material&quot;</span>){}</div>
<div class="line">    <span class="keywordtype">void</span>* <a class="code" href="class_f_e_core_factory.html#a4ced76d9cb0b0489eb5778931f56e477">Create</a>(<a class="code" href="class_f_e_model.html">FEModel</a>* pfem) { <span class="keywordflow">return</span> <span class="keyword">new</span> MyMaterial(pfem); }</div>
<div class="line">};</div>
</div><!-- fragment --><p>Note that the constructor of the base class <a class="el" href="class_f_e_core_factory.html" title="The factory class contains the mechanism for instantiating a class. ">FECoreFactory</a> takes two parameters. A super class ID which defines the type of class that the factory creates (a material in this case) and a name that uniquely defines the class. This name will later be used to define the material in the user-input file and can also be used for other purposes.</p>
<h2><a class="anchor" id="step3"></a>
Defining the material parameters</h2>
<p>Defining the material parameters of the class requires two steps. First, variables need to be defined that will store the values for these parameters. In our example, the <a class="el" href="class_f_e_neo_hookean.html" title="Neo Hookean material. ">FENeoHookean</a> class defines two parameters: m_E stores the Young's modulus and m_v stores the Poisson's ratio. Note that these variables are defined as public. This is important, since only public variables can be used by FEBio's framework. The second step is to register the material parameters with FEBio's framework. A set of macros exist that will facilitate this process. The first one is placed in the class definition.</p>
<div class="fragment"><div class="line">DECLARE_PARAMETER_LIST();</div>
</div><!-- fragment --><p>This macro informs FEBio that this material class will be defining a set of material parameters. The actual definition of the material parameter list is placed in the compilation unit (i.e. the .cpp file). In our example, this list is found at the top of the FENeoHookean.cpp file.</p>
<div class="fragment"><div class="line">BEGIN_PARAMETER_LIST(<a class="code" href="class_f_e_neo_hookean.html">FENeoHookean</a>, <a class="code" href="class_f_e_elastic_material.html">FEElasticMaterial</a>);</div>
<div class="line">    ADD_PARAMETER(m_E, FE_PARAM_DOUBLE, <span class="stringliteral">&quot;E&quot;</span>);</div>
<div class="line">    ADD_PARAMETER(m_v, FE_PARAM_DOUBLE, <span class="stringliteral">&quot;v&quot;</span>);</div>
<div class="line">END_PARAMETER_LIST();</div>
</div><!-- fragment --><p>The parameter list definition begins with the BEGIN_PARAMETER_LIST macro, which takes two parameters: the name of the class, and the name of the base class. Next, for each parameter, the ADD_PARAMETER macro can be used to define it. This macro takes three parameters: the variable that will store the parameter's value, a type identifier and a string name for the variable. The type of the type identifier can be any of the following values.</p>
<ul>
<li>FE_PARAM_INT: defines a parameter of type int. </li>
<li>FE_PARAM_BOOL: defines a parameter of type bool. </li>
<li>FE_PARAM_DOUBLE: defines a parameter of type double.</li>
</ul>
<p>Note that the type identifier must match the type of the actual variable. For example, a double variable must be defined with the FE_PARAM_DOUBLE type identifier. If the types do not match, the resulting behavior is undefined.</p>
<p>Finally, the parameter list must be ended with the END_PARAMETER_LIST macro. Note that there a couple of more advanced options to define material parameters, such as vector parameters and load-curve controlled parameters. These will be discussed in the advanced section below.</p>
<h2><a class="anchor" id="step4"></a>
Implementing the initialization function</h2>
<p>When implementing a new material class the user has the option to override the base class implementation of the Init function. This function is called after the material parameters have been read from the input file and can be used to check the values of these parameters. In our example, this function is declared as follows.</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> <a class="code" href="class_f_e_neo_hookean.html#adae9c15f1590c97bb4ba979f650dc558">FENeoHookean::Init</a>()</div>
<div class="line">{</div>
<div class="line">        <a class="code" href="class_f_e_elastic_material.html#afd01ead5455c00e3d721cd959f68399a">FEElasticMaterial::Init</a>();</div>
<div class="line"></div>
<div class="line">        <span class="keywordflow">if</span> (<a class="code" href="class_f_e_neo_hookean.html#a152e5b285a5e0e32af668e0907d28c71">m_E</a> &lt;= 0) <span class="keywordflow">throw</span> <a class="code" href="class_material_error.html">MaterialError</a>(<span class="stringliteral">&quot;Invalid value for E&quot;</span>);</div>
<div class="line">        <span class="keywordflow">if</span> (!INRANGE(<a class="code" href="class_f_e_neo_hookean.html#a47f3436c17fdae4e73b7b77ddf423d9c">m_v</a>, -1, 0.5)) <span class="keywordflow">throw</span> <a class="code" href="class_material_error.html">MaterialError</a>(<span class="stringliteral">&quot;Invalid ...</span></div>
<div class="line"><span class="stringliteral">}</span></div>
</div><!-- fragment --><p>First note line 3 where the base class version of this function is called. It is good practice to always call this function so that the base class has a chance to check itself. Even though the base class implementation may do nothing, it is best not to assume this and always call the base class version.</p>
<p>The next two lines check the values of the parameters as they have been read from the user input file. If an invalid parameter value is encountered the user can report a problem by throwing the <a class="el" href="class_material_error.html" title="exception to throw during the material initialization phase ">MaterialError</a> exception. This exception accepts a variable-argument list, similarly to the printf class of functions. Throwing this error will cause the run to be aborted with a fatal error. The error message will be printed on the screen as well as to the log file.</p>
<p>Again, it is noted that this function is optional, but it is recommended to implement it so that potential problems due to invalid material parameters can be caught quickly.</p>
<h2><a class="anchor" id="step5"></a>
Implementing the stress and tangent functions</h2>
<p>Next follows the most important aspect of the implementation: the declaration of the stress and tangent functions. These functions will describe the physical reaction of this material to an applied deformation. Note that FEBio works in the spatial frame. This implies that the stress function needs to return the Cauchy stress and the tangent function needs to return the spatial elasticity tensor.</p>
<p>The stress function is defined as follows in the material class definition (i.e. the header file).</p>
<div class="fragment"><div class="line"><a class="code" href="classmat3ds.html">mat3ds</a> stress(<a class="code" href="class_f_e_material_point.html">FEMaterialPoint</a>&amp; pt);</div>
</div><!-- fragment --><p>This function takes one parameter of type <a class="el" href="class_f_e_material_point.html" title="Material point class. ">FEMaterialPoint</a>. This parameter stores all the important information about the point at which to calculate the stress value. For example, this variable stores the reference and current location of the point, the local deformation gradient, history variables (if defined) and much more. It also defines a bunch of useful functions that can facilitate the implementation of the stress function, such as a function that calculates the left and right Cauchy-Green tensors. There is a lot to say about this class, but in order not to digress, a detailed explanation of this class is postponed and only a few important aspects of it are mentioned here.</p>
<p>The actual definition of the stress function is, as usual, placed in the compilation unit. In our example, this is the FENeoHookean.cpp file.</p>
<div class="fragment"><div class="line"><a class="code" href="classmat3ds.html">mat3ds</a> <a class="code" href="class_f_e_neo_hookean.html#aad1f0effb7279cb2df0264df25696d2a">FENeoHookean::Stress</a>(<a class="code" href="class_f_e_material_point.html">FEMaterialPoint</a>&amp; mp)</div>
<div class="line">{</div>
<div class="line"> <a class="code" href="class_f_e_elastic_material_point.html">FEElasticMaterialPoint</a>&amp; pt =  mp.ExtractData&lt;<a class="code" href="class_f_e_elastic_material_point.html">FEElasticMaterialPoint</a>&gt;();</div>
<div class="line"></div>
<div class="line"> <a class="code" href="classmat3d.html">mat3d</a> &amp;F = pt.F;</div>
<div class="line"> <span class="keywordtype">double</span> detF = pt.J;</div>
<div class="line"> <span class="keywordtype">double</span> detFi = 1.0/detF;</div>
<div class="line"> <span class="keywordtype">double</span> lndetF = log(detF);</div>
<div class="line"></div>
<div class="line">  <span class="comment">// calculate left Cauchy-Green tensor</span></div>
<div class="line">  <span class="comment">// (we commented out the matrix components we do not need)</span></div>
<div class="line">  <a class="code" href="classmat3ds.html">mat3ds</a> b = pt.<a class="code" href="class_f_e_elastic_material_point.html#ad717969362a4b348b502f913509673ce">LeftCauchyGreen</a>();</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// lame parameters</span></div>
<div class="line">  <span class="keywordtype">double</span> lam = <a class="code" href="class_f_e_neo_hookean.html#a47f3436c17fdae4e73b7b77ddf423d9c">m_v</a>*<a class="code" href="class_f_e_neo_hookean.html#a152e5b285a5e0e32af668e0907d28c71">m_E</a>/((1+<a class="code" href="class_f_e_neo_hookean.html#a47f3436c17fdae4e73b7b77ddf423d9c">m_v</a>)*(1-2*<a class="code" href="class_f_e_neo_hookean.html#a47f3436c17fdae4e73b7b77ddf423d9c">m_v</a>));</div>
<div class="line">  <span class="keywordtype">double</span> mu  = 0.5*<a class="code" href="class_f_e_neo_hookean.html#a152e5b285a5e0e32af668e0907d28c71">m_E</a>/(1+<a class="code" href="class_f_e_neo_hookean.html#a47f3436c17fdae4e73b7b77ddf423d9c">m_v</a>);</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Identity</span></div>
<div class="line">  <a class="code" href="classmat3dd.html">mat3dd</a> I(1);</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// calculate stress</span></div>
<div class="line">  <a class="code" href="classmat3ds.html">mat3ds</a> s = (b - I)*(mu*detFi) + I*(lam*lndetF*detFi);</div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">return</span> s;</div>
<div class="line"> }</div>
</div><!-- fragment --><p>Although the detailed implementation of this constitutive model will not be explained, a few important points are noted.</p>
<p>On line 3 a perhaps strange construction appears. As mentioned before, the material point stores all the information about the current point at which the stress is required. This class however, stores its data per material type. In this example only elastic materials are mentioned (that is, materials derived from the <a class="el" href="class_f_e_elastic_material.html" title="Base class for (hyper-)elastic materials. ">FEElasticMaterial</a> class), but there are other types of materials as will be discussed in the advanced section below. Each material type can define different attributes that need to be stored in the material point class. In order to access the data that corresponds to a particular material class, the user can use the ExtractData member function of the material point class. The class returns the subset of data that are relevant for this class of material. In this case the returned data is of the type <a class="el" href="class_f_e_elastic_material_point.html" title="This class defines material point data for elastic materials. ">FEElasticMaterialPoint</a>.</p>
<p>On line 5, the local deformation gradient is accessed from the material point data and on line 6, the local Jacobian (which is the determinant of the deformation gradient ). These are data members that can be accessed directly. Line 12 illustrates how to obtain additional information using the material point’s member functions. In this case, the left Cauchy-Green tensor is retrieved using the LeftCauchyGreen member function. A more detailed description of the available data and function members can be found in the advanced section.</p>
<p>Line 22 shows an example of how the actual stress can be computed. FEBio defines a whole bunch of classes that facilitate the use of tensors. For example, the <a class="el" href="classmat3ds.html" title="This class describes a symmetric 3D matrix of doubles. ">mat3ds</a> class implements a second-order 3D symmetric tensor of doubles (the d stands for double). The <a class="el" href="classmat3dd.html" title="This class describes a diagonal matrix of doubles in 3D. ">mat3dd</a> class implements a second-order 3D diagonal tensor. We will see some examples of fourth-order tensor classes in the tangent function.</p>
<p>Line 24 returns the calculated stress value at the current material point. Note that the variable returned is of type <a class="el" href="classmat3ds.html" title="This class describes a symmetric 3D matrix of doubles. ">mat3ds</a>, that is, a symmetric second-order tensor.</p>
<p>The tangent function is declared in the class definition as well.</p>
<div class="fragment"><div class="line"><a class="code" href="classtens4ds.html">tens4ds</a> Tangent(<a class="code" href="class_f_e_material_point.html">FEMaterialPoint</a>&amp; pt);</div>
</div><!-- fragment --><p>This function too takes a single <a class="el" href="class_f_e_material_point.html" title="Material point class. ">FEMaterialPoint</a> variable as input. Note that in this case the return value is of type <a class="el" href="classtens4ds.html" title="class for 4th order tensors with major and minor symmetries. ">tens4ds</a> which is a class that implements a fourth-order tensor with major and minor symmetries. The definition of the function can be found in the FENeoHookean.cpp file.</p>
<div class="fragment"><div class="line"><a class="code" href="classtens4ds.html">tens4ds</a> <a class="code" href="class_f_e_neo_hookean.html#a267374187b8d7f55f5058814ef8a4197">FENeoHookean::Tangent</a>(<a class="code" href="class_f_e_material_point.html">FEMaterialPoint</a>&amp; mp)</div>
<div class="line">{</div>
<div class="line">   <a class="code" href="class_f_e_elastic_material_point.html">FEElasticMaterialPoint</a>&amp; pt = *mp.ExtractData&lt;<a class="code" href="class_f_e_elastic_material_point.html">FEElasticMaterialPoint</a>&gt;();</div>
<div class="line"></div>
<div class="line">    <span class="comment">// deformation gradient</span></div>
<div class="line">    <a class="code" href="classmat3d.html">mat3d</a> &amp;F = pt.F;</div>
<div class="line">    <span class="keywordtype">double</span> detF = pt.J;</div>
<div class="line"></div>
<div class="line">    <span class="comment">// lame parameters</span></div>
<div class="line">    <span class="keywordtype">double</span> lam = <a class="code" href="class_f_e_neo_hookean.html#a47f3436c17fdae4e73b7b77ddf423d9c">m_v</a>*<a class="code" href="class_f_e_neo_hookean.html#a152e5b285a5e0e32af668e0907d28c71">m_E</a>/((1+<a class="code" href="class_f_e_neo_hookean.html#a47f3436c17fdae4e73b7b77ddf423d9c">m_v</a>)*(1-2*<a class="code" href="class_f_e_neo_hookean.html#a47f3436c17fdae4e73b7b77ddf423d9c">m_v</a>));</div>
<div class="line">    <span class="keywordtype">double</span> mu  = 0.5*<a class="code" href="class_f_e_neo_hookean.html#a152e5b285a5e0e32af668e0907d28c71">m_E</a>/(1+<a class="code" href="class_f_e_neo_hookean.html#a47f3436c17fdae4e73b7b77ddf423d9c">m_v</a>);</div>
<div class="line"></div>
<div class="line">    <span class="keywordtype">double</span> lam1 = lam / detF;</div>
<div class="line">    <span class="keywordtype">double</span> mu1  = (mu - lam*log(detF)) / detF;</div>
<div class="line"></div>
<div class="line">    <a class="code" href="classmat3dd.html">mat3dd</a> I(1);</div>
<div class="line">    <a class="code" href="classtens4ds.html">tens4ds</a> IxI = dyad1s(I);</div>
<div class="line">    <a class="code" href="classtens4ds.html">tens4ds</a> I4 = dyad4s(I);</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">return</span> IxI*lam1 + I4*(2*mu1);</div>
<div class="line">}</div>
</div><!-- fragment --><p>In line 3 the data of the material data that pertains to elastic materials is extracted. The next few lines extract some data from the <a class="el" href="class_f_e_elastic_material_point.html" title="This class defines material point data for elastic materials. ">FEElasticMaterialPoint</a> variable and calculate some other parameters.</p>
<p>Lines 16 and following calculate the tangent stiffness. Note the use of the fourth-order tensor class <a class="el" href="classtens4ds.html" title="class for 4th order tensors with major and minor symmetries. ">tens4ds</a>. This code snippet also illustrates the use of the dyadic products to create fourth-order tensors from second-order tensors. A more detailed explanation of the use of the tensor classes can be found in chapter 3.</p>
<p>In addition to the material classes defining solid materials, there are several classes defining materials relevant to biphasic and multiphasic mixtures. These are briefly described here.</p>
<h1><a class="anchor" id="mat_sec2"></a>
The FEElasticMaterialPoint class</h1>
<p>As was shown above, the stress and tangent are evaluated at so-called material points. These are points at which the state of the deformation is tracked. Most often, these points correspond to the integration points of the elements. Material points are implemented by deriving special classes from the <a class="el" href="class_f_e_material_point.html" title="Material point class. ">FEMaterialPoint</a> base class. A class of particular importance is the <a class="el" href="class_f_e_elastic_material_point.html" title="This class defines material point data for elastic materials. ">FEElasticMaterialPoint</a> class which is used to define the state of hyper-elastic materials. Unless your material implementation requires additional (history-dependent) data, this is the class you will use in the stress and tangent functions.</p>
<p>The <a class="el" href="class_f_e_elastic_material_point.html" title="This class defines material point data for elastic materials. ">FEElasticMaterialPoint</a> class defines the state of an elastic material point, or more precisely, the state of a material derived from the <a class="el" href="class_f_e_elastic_material.html" title="Base class for (hyper-)elastic materials. ">FEElasticMaterial</a> class. It defines the following state variables.</p>
<ul>
<li><a class="el" href="classvec3d.html">vec3d</a> r0: the position of the material point in the reference frame </li>
<li><a class="el" href="classvec3d.html">vec3d</a> rt: the position of the material point in the spatial frame </li>
<li><a class="el" href="classmat3d.html" title="This class describes a general 3D matrix of doubles. ">mat3d</a> F: the deformation gradient </li>
<li>double J: the Jacobian, that is the determinant of the deformation gradient </li>
<li><a class="el" href="classmat3d.html" title="This class describes a general 3D matrix of doubles. ">mat3d</a> Q: a rotation matrix describing the element coordinate system </li>
<li><a class="el" href="classmat3ds.html" title="This class describes a symmetric 3D matrix of doubles. ">mat3ds</a> s: the Cauchy stress tensor</li>
</ul>
<p>If your material derives from <a class="el" href="class_f_e_elastic_material.html" title="Base class for (hyper-)elastic materials. ">FEElasticMaterial</a> (or <a class="el" href="class_f_e_uncoupled_material.html" title="Base class for uncoupled hyperelastic material formulations. ">FEUncoupledMaterial</a>) and no additional state data is required, you do not need to derive a new material point class. For all elastic materials this is the default material point data class to store the point data.</p>
<p>This class also defines some useful functions that can facilitate the implementation of stress and tangent functions.</p>
<ul>
<li>Strain: Calculate the Euler-Lagrange strain tensor. </li>
<li>RightCauchyGreen: Calculate the right Cauchy-Green strain tensor. </li>
<li>RightCauchyGreen: Calculate the left Cauchy-Green strain tensor. </li>
<li>DevRightCauchyGreen: Calculate the deviatoric right Cauchy-Green tensor. </li>
<li>DevLeftCauchyGreen: Calculate the deviatoric left Cauchy-Green tensor. </li>
<li>pull_back: Calculate the pull-back of a 2nd order tensor. </li>
<li>push_back: Calculates the push-back of a tensor. Two versions are defined. One for 2nd order symmetric tensors, and one for 4th order symmetric tensors.</li>
</ul>
<p>For materials that require additional information to be stored at the material points (e.g. history-dependent materials) a new material point class needs to be defined, by deriving from the <a class="el" href="class_f_e_elastic_material_point.html" title="This class defines material point data for elastic materials. ">FEElasticMaterialPoint</a> class. See section 2.4.3 for more information.</p>
<h1><a class="anchor" id="mat_sec3"></a>
Using the new material class</h1>
<p>If the steps to register the material and its material parameters have been followed as outlined in the previous sections, the material class will be seamlessly integrated in FEBio's framework. One of the important consequences of this is that the xml-input file reader will automatically recognize the new material and its parameters. For example, imagine the user created a new class MyFancyMaterial and named it "fancy material" by registering the material as follows.</p>
<div class="fragment"><div class="line">REGISTER_FEBIO_CLASS(MyFancyMaterial, FEMATERIAL_ID, <span class="stringliteral">&quot;fancy material&quot;</span>);</div>
</div><!-- fragment --><p>This macro associates the name "fancy material" with the MyFancyMaterial class. This name will now be used as the type identifier in the xml-input file.</p>
<div class="fragment"><div class="line">&lt;material <span class="keywordtype">id</span>=<span class="stringliteral">&quot;1&quot;</span> type=<span class="stringliteral">&quot;fancy material&quot;</span>&gt;</div>
<div class="line">    ...</div>
<div class="line">&lt;/material&gt;</div>
</div><!-- fragment --><p>FEBio will recognize the type identifier as the name of the MyFancyMaterial class and will create an instance of this class. For all the elements in the mesh that have the material ID of this class (in this case "1"), the stress and tangent functions of the new class will be automatically called.</p>
<p>Material parameters are identified in a similar way. For each material parameter, the ADD_PARAMETER macro associates a name with the parameter. For example, imagine that for our new class MyFancyMaterial the following parameter is defined,</p>
<div class="fragment"><div class="line">ADD_PARAMETER(m_a, FE_DOUBLE_PARAM, <span class="stringliteral">&quot;param_a&quot;</span>);</div>
</div><!-- fragment --><p>The user can now enter a value for this parameter in the FEBio input file as follows,</p>
<div class="fragment"><div class="line">&lt;material <span class="keywordtype">id</span>=<span class="stringliteral">&quot;1&quot;</span> type=<span class="stringliteral">&quot;fancy material&quot;</span>&gt;</div>
<div class="line">    &lt;param_a&gt;0.123&lt;/param_a&gt;</div>
<div class="line">&lt;/material&gt;</div>
</div><!-- fragment --><p>FEBio will now automatically read the value (here 0.123) and store it in the m_a variable which will be defined as a public member variable of the MyFancyMaterial class.</p>
<h1><a class="anchor" id="mat_sec4"></a>
Debugging the Material Implementation</h1>
<p>Implementing a new material formulation can be tricky sometimes. Particularly the implementation of the correct tangent stiffness is often quite challenging. For this reason, FEBio offers a few tools that can help in diagnosing a new material implementation.</p>
<p>First, it is highly recommended to use the available tensor classes to implement the stress and tangent stiffness of the material. These classes allow the user to stay as true as possible to the mathematical formulation, facilitating the readability of the code. Obvious mistakes, such as sign errors, will therefore be relatively easy to spot by direct comparison of the code with the mathematical equations.</p>
<p>FEBio also offers a tangent diagnostic tool, which allows the user a more direct inspection of this tangent implementation. The tool basically compares the actual implementation of the tangent with an approximation that is obtained by calculating the finite difference of the residual. To run the diagnostic, a separate FEBio input file needs to be defined. An example for the neo-Hookean material follows.</p>
<div class="fragment"><div class="line">&lt;?xml version=<span class="stringliteral">&quot;1.0&quot;</span>?&gt;</div>
<div class="line">&lt;febio_diagnostic type=<span class="stringliteral">&quot;tangent test&quot;</span>&gt;</div>
<div class="line">        &lt;Control&gt;</div>
<div class="line">            &lt;time_steps&gt;1&lt;/time_steps&gt;</div>
<div class="line">        &lt;step_size&gt;1&lt;/step_size&gt;</div>
<div class="line">        &lt;plot_level&gt;PLOT_DEFAULT&lt;/plot_level&gt;</div>
<div class="line">        &lt;/Control&gt;</div>
<div class="line">        &lt;Scenario type=<span class="stringliteral">&quot;uni-axial&quot;</span>&gt;</div>
<div class="line">            &lt;strain&gt;0.15&lt;/strain&gt;</div>
<div class="line">        &lt;/Scenario&gt;</div>
<div class="line">        &lt;Material&gt;</div>
<div class="line">            &lt;material <span class="keywordtype">id</span>=<span class="stringliteral">&quot;1&quot;</span> name=<span class="stringliteral">&quot;Solid&quot;</span> type=<span class="stringliteral">&quot;neo-Hookean&quot;</span>&gt;</div>
<div class="line">                &lt;E&gt;1&lt;/E&gt;</div>
<div class="line">                &lt;v&gt;0.45&lt;/v&gt;</div>
<div class="line">            &lt;/material&gt;</div>
<div class="line">        &lt;/Material&gt;</div>
<div class="line"> &lt;/febio_diagnostic&gt;</div>
</div><!-- fragment --><p>The diagnostics input file also takes an xml-formatted input file and is structured similarly as the FEBio input file. The first line is the xml declaration as required by the xml standard. The next line defines the root element of the xml format. In this case, it is defined as febio_diagnostics to indicate that this file is a diagnostics file. The name attribute identifies the type of diagnostic this file describes, and in this case this is a "tangent test". Next follows the definition of the three sections of the file.</p>
<p>The first section, the Control section, defines some general control settings such as the number of timesteps, time step size and so on.</p>
<p>The second section, the Scenario section, defines the type of model and boundary conditions to apply. This section replaces the geometry section in the usual FEBio input file. The geometry is now defined implicitly through the scenario. The uni-axial scenario runs a simple uni-axial tension or compression problem on a unit cube. The maximum strain level can be defined through the strain parameter.</p>
<p>The third section defines the material that will be assigned to the model. In the uni-axial scenario, only one material needs to be defined with the corresponding material parameters. Note that when the material class is properly registered with the framework as explained above, no additional steps need to be taken to use the tangent diagnostics feature aside from creating the diagnostics input file for the new material.</p>
<p>To run the tangent diagnostic, simply type the following at the command prompt.</p>
<div class="fragment"><div class="line">&gt;febio -d filename [ENTER]</div>
</div><!-- fragment --><p>Note that the command option –d needs to be used instead of the usual –i to inform FEBio that you are running a diagnostics problem and not a regular model. Replace "filename" with the name of the actual input file.</p>
<p>This diagnostic test outputs a log file that contains the tangent stiffness as calculated from the implementation and a finite difference approximation to this tangent. It also contains the difference between these two matrices and the matrix element where the difference is largest. Although a small difference between the two matrices can be expected due to the finite difference approximation, the difference should be small, e.g. less than 0.01%. If this is not the case, there is probably a mistake in either the Stress function or in the Tangent function or both. To identify the culprit, the result of the simulation, which is reported as usual in the plot file, can be compared to a known solution (or a solution obtained in a different fashion). If the solutions correspond, then the problem most likely lies with the tangent implementation. If the solutions do not agree, then the implementation of the Cauchy stress is probably also erroneous.</p>
<h1><a class="anchor" id="mat_sec5"></a>
Advanced Topics</h1>
<h2><a class="anchor" id="subsec61"></a>
Array parameters</h2>
<p>It is possible to define an array of parameters using a single material parameter declaration. This can be done by first defining a member variable as an array in the class definition. For example, imagine that the new material class has the following variable declared.</p>
<div class="fragment"><div class="line"><span class="keywordtype">double</span>  m_a[3];</div>
</div><!-- fragment --><p>To define the variable m_a as the storage for a material parameter, the user can use the ADD_PARAMETERV macro. For example,</p>
<div class="fragment"><div class="line">ADD_PARAMETERV(m_a, FE_PARAM_DOUBLE, 3, <span class="stringliteral">&quot;a&quot;</span>);</div>
</div><!-- fragment --><p>This macro requires four parameters. The first parameter is the variable that will store the material parameters. The second is the type of the variable. In this case the variable m_a is declared as an array of doubles, so the FE_PARAM_DOUBLE has to be used. The third parameter is the size of the array and the fourth parameter is the string name of the variable that will be used to identify the variable in the FEBio input file. In the input file, the parameter’s values can then be defined using a comma-separated list. For example,</p>
<div class="fragment"><div class="line">&lt;a&gt;0.1, 0.23, -0.73&lt;/a&gt;</div>
</div><!-- fragment --><p>There is no limitation on the size of array parameters. Currently, the only types that are supported for array parameters are int and double. These are declared using the FE_PARAM_INT and FE_PARAM_DOUBLE identifier respectively.</p>
<h2><a class="anchor" id="subsec62"></a>
Uncoupled Materials</h2>
<p>Incompressible materials are an important class of materials since they are dealt with in a very particular manner. FEBio assumes that such materials use a decoupled hyperelastic strain energy function.</p>
<p class="formulaDsp">
\[ W(\mathbf{C})=\tilde{W}(\tilde{\mathbf{C}})+U(J) \]
</p>
<p>Here, \(\mathbf{C}\) is the right Cauchy-Green tensor, \(\tilde{\mathbf{C}}\) is the deviatoric right Cauchy-Green tensor and J is the Jacobian. Since the incompressibility constraint can sometimes be hard to enforce for these materials with the usual displacement formulation of FE, a different formulation is used. FEBio uses a three-field formulation that requires a separate integration rule for the dilatational stiffness contribution. We refer to the FEBio theory manual for a more detailed description of the theory of incompressible hyperelasticity. As a consequence of the different formulation, incompressible materials require a few changes to the basic procedure.</p>
<p>First, incompressible materials using a decoupled strain energy function, need to be derived from the base class <a class="el" href="class_f_e_uncoupled_material.html" title="Base class for uncoupled hyperelastic material formulations. ">FEUncoupledMaterial</a>. An example of such a class is the <a class="el" href="class_f_e_mooney_rivlin.html" title="Mooney-Rivlin material. ">FEMooneyRivlin</a> material. This class is defined as follows.</p>
<div class="fragment"><div class="line"><span class="keyword">class </span><a class="code" href="class_f_e_mooney_rivlin.html">FEMooneyRivlin</a> : <span class="keyword">public</span> <a class="code" href="class_f_e_uncoupled_material.html">FEUncoupledMaterial</a></div>
<div class="line">{</div>
<div class="line">    <span class="comment">//  ...</span></div>
<div class="line">};</div>
</div><!-- fragment --><p>The second important difference relates to the calculation of the stress. For a material with an uncoupled strain energy function, the stress is given by,</p>
<p class="formulaDsp">
\[ \mathbf{\sigma} = p\mathbf{I}+\frac{2}{J}\text{dev}(\mathbf{\tilde{F}}\frac{\partial W}{\partial C}\mathbf{\tilde{F}}^{T}) \]
</p>
<p>The pressure p is calculated by FEBio. The only thing that the material class needs to implement is the second term. This must be done in the DevStress member function which is inherited from <a class="el" href="class_f_e_uncoupled_material.html" title="Base class for uncoupled hyperelastic material formulations. ">FEUncoupledMaterial</a>. For example, for the Mooney-Rivlin material, the stress is calculated as follows.</p>
<div class="fragment"><div class="line"><a class="code" href="classmat3ds.html">mat3ds</a> <a class="code" href="class_f_e_mooney_rivlin.html#a66b05eb9dc5003e57871b0d62171574b">FEMooneyRivlin::DevStress</a>(<a class="code" href="class_f_e_material_point.html">FEMaterialPoint</a>&amp; mp)</div>
<div class="line">{</div>
<div class="line">        <a class="code" href="class_f_e_elastic_material_point.html">FEElasticMaterialPoint</a>&amp; pt = *mp.ExtractData&lt;<a class="code" href="class_f_e_elastic_material_point.html">FEElasticMaterialPoint</a>&gt;();</div>
<div class="line">        ...</div>
<div class="line">        <a class="code" href="classmat3ds.html">mat3ds</a> T = B*(W1 + W2*I1) - B2*W2;</div>
<div class="line"></div>
<div class="line">        <span class="keywordflow">return</span> T.dev()*(2.0/J);</div>
<div class="line">}</div>
</div><!-- fragment --><p>Similarly, the elasticity tensor requires a slightly different form. It can be shown that it can be decomposed as follows.</p>
<h2><a class="anchor" id="subsec63"></a>
User-defined material points</h2>
<p>In the previous sections we touched briefly on the concept of material points. In this section we will elaborate on this important topic and discuss how it can be used to add additional element data, e.g. for use in history-dependent materials.</p>
<p>A material point is a point in the material at which the state is stored. Usually these correspond to the integration points of the elements. The state of the material at this point is defined by the position, the deformation gradient, the stress and so forth.</p>
<p>The <a class="el" href="class_f_e_material_point.html" title="Material point class. ">FEMaterialPoint</a> class (defined in <a class="el" href="_f_e_material_point_8h_source.html">FEMaterialPoint.h</a>) defines the base class from which all material point classes are derived. It does not define any state data, except for two variables, namely time, which defines the current time value and dt, which defines the current time increment. To define additional material data, one would need to derive a new material point class from this base class.</p>
<p>Note that this class is an abstract base class since it defines several virtual functions that have no definition. These functions have to be defined in the derived class. They are the following functions: Init, Copy and Serialize.</p>
<p>The Init function is called before the start of each time step. It has one parameter, bflag, a Boolean flag that indicates whether this is the first time this function is called. During the first time this function is called, you can allocate and initialize data variables.</p>
<p>The Copy member is called to create a shallow copy of the material point class. This is used to store the current state of the material point before the time step begins. When the time step fails this copy function allows FEBio to recover the data from the last converged time step and restart the time step using a smaller time step.</p>
<p>The Serialize function is used to store (and read) the material point data to (from) the data archive, a file stored on disk and used for cold restarts.</p>
<p>As discussed above, one particularly important material point class is the <a class="el" href="class_f_e_elastic_material_point.html" title="This class defines material point data for elastic materials. ">FEElasticMaterialPoint</a> class which stores the state data for all elastic materials. If your new material is an elastic material, you probably don’t need to redefine a new material point class. See section 2.2 for a detailed discussion of this material point class. However, if any additional data is required that is not stored in the default material point classes, a new material point class must be defined. For elastic materials, it is best to derive a new material point class from the <a class="el" href="class_f_e_elastic_material_point.html" title="This class defines material point data for elastic materials. ">FEElasticMaterialPoint</a> class. </p>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="index.html">FEBio Developer's Manual</a></li><li class="navelem"><a class="el" href="plugins.html">FEBio Plugins</a></li>
    <li class="footer">Generated on Mon May 19 2014 13:39:34 for FEBio by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.7 </li>
  </ul>
</div>
</body>
</html>
